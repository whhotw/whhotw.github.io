<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Js | wlog]]></title>
  <link href="http://whhotw.github.io/blog/categories/js/atom.xml" rel="self"/>
  <link href="http://whhotw.github.io/"/>
  <updated>2018-01-11T22:52:15+08:00</updated>
  <id>http://whhotw.github.io/</id>
  <author>
    <name><![CDATA[w]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[淺拷貝 vs. 深拷貝]]></title>
    <link href="http://whhotw.github.io/blog/2018/01/11/"/>
    <updated>2018-01-11T22:21:31+08:00</updated>
    <id>http://whhotw.github.io/blog/2018/01/</id>
    <content type="html"><![CDATA[<h3>複製物件你可能會這麼寫</h3>

<pre><code>let a = {a: '1', b: '2', c: '3'};
let x = a;
x.a = 10
console.log(a); // {a: '10', b: '2', c: '3'}
console.log(x === a); // true
</code></pre>

<p>為什麼新的變數內容改變，舊的變數內容也會變呢？因為以上的寫法為<code>淺拷貝</code>但是很多時候我們並不想這樣，這時候就需要改成<code>深拷貝</code>的寫法</p>

<p>&ndash;</p>

<h3>淺拷貝 => 分身術</h3>

<p>外表（值）長得一樣，靈魂（記憶體位置）<strong>相同</strong></p>

<h3>深拷貝 => 雙胞胎</h3>

<p>外表（值）長得一樣，靈魂（記憶體位置）<strong>不同</strong></p>

<h3>比較圖</h3>

<p><img src="http://i.stack.imgur.com/hOPkR.png" alt="image" /></p>

<p>&ndash;</p>

<h3>Object.assign</h3>

<p>ES6 上可以用的函式但只能處理深度只有一層的物件</p>

<pre><code>let a = {a: '1', b: '2', c: '3'};
let x = Object.assign({}, a);
x.a = 10
console.log(a); // {a: '1', b: '2', c: '3'}
console.log(x === a); // false
</code></pre>

<h3>lodash</h3>

<p>網路上熱門的<a href="https://lodash.com/">函式庫</a></p>

<pre><code>let _ = require('lodash');
let a = {a: '1', b: '2', c: '3'};
let x = _.cloneDeep(a);
x.a = 10
console.log(a); // {a: '1', b: '2', c: '3'}
console.log(x === a); // false
</code></pre>
]]></content>
  </entry>
  
</feed>
