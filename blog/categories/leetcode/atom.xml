<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Leetcode | wlog]]></title>
  <link href="http://whhotw.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://whhotw.github.io/"/>
  <updated>2018-09-18T19:03:41+08:00</updated>
  <id>http://whhotw.github.io/</id>
  <author>
    <name><![CDATA[w]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[LeetCode #766 Toeplitz Matrix]]></title>
    <link href="http://whhotw.github.io/blog/2018/09/18/leetcode-number-766-toeplitz-matrix/"/>
    <updated>2018-09-18T18:58:19+08:00</updated>
    <id>http://whhotw.github.io/blog/2018/09/18/leetcode-number-766-toeplitz-matrix</id>
    <content type="html"><![CDATA[<pre><code>var isToeplitzMatrix = function(matrix) {
    let a = true;
    for (let i = 0; i &lt; matrix.length; i++) {
        let j = 0;
        while (j + 1 &lt; matrix[i].length &amp;&amp; i + 1 &lt; matrix.length) {
            console.log(i + 1, j + 1);
            if (matrix[i][j] !== matrix[i + 1][j + 1]) {
                a = false;
            }

            j++;
        }
    }

    return a;
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LeetCode #717. 1-bit and 2-bit Characters]]></title>
    <link href="http://whhotw.github.io/blog/2018/01/31/leetcode-number-717-1-bit-and-2-bit-characters/"/>
    <updated>2018-01-31T10:38:51+08:00</updated>
    <id>http://whhotw.github.io/blog/2018/01/31/leetcode-number-717-1-bit-and-2-bit-characters</id>
    <content type="html"><![CDATA[<pre><code>const len = bits.length - 1;
let i = 0;
while (i &lt; len) {
    if (bits[i] === 0) {
        i++;
    } else if (bits[i] === 1) {
        if (i + 1 === len) {
            return false;
        }

        i += 2;
    }
}

return true;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LeetCode #581. Shortest Unsorted Continuous Subarray]]></title>
    <link href="http://whhotw.github.io/blog/2018/01/29/leetcode-number-581-shortest-unsorted-continuous-subarray/"/>
    <updated>2018-01-29T18:45:26+08:00</updated>
    <id>http://whhotw.github.io/blog/2018/01/29/leetcode-number-581-shortest-unsorted-continuous-subarray</id>
    <content type="html"><![CDATA[<pre><code>let n = nums.map((val) =&gt; val);
nums.sort();

let l = 0;
let r = n.length;

while (l &lt;= r) {
    if (n[l] === nums[l]) {
        l++;
    } else if (n[r] === nums[r]) {
        r--;
    } else {
        break;
    }
}

return l &gt; r ? 0 : r - l + 1;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LeetCode #493. Reverse Pairs]]></title>
    <link href="http://whhotw.github.io/blog/2018/01/28/leetcode-number-493-reverse-pairs/"/>
    <updated>2018-01-28T10:48:40+08:00</updated>
    <id>http://whhotw.github.io/blog/2018/01/28/leetcode-number-493-reverse-pairs</id>
    <content type="html"><![CDATA[<pre><code>for (let i = 0; i &lt; nums.length; i++) {
    for (let j = 0; j &lt; nums.length; j++) {
        if (i &lt; j &amp;&amp; nums[i] &gt; 2 * nums[j]) {
            x++;
        }
    }
}
</code></pre>

<blockquote><p>Big O(n<sup>2</sup>)</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LeetCode #2. Add Two Numbers]]></title>
    <link href="http://whhotw.github.io/blog/2017/11/28/leetcode-number-2-add-two-numbers/"/>
    <updated>2017-11-28T17:31:11+08:00</updated>
    <id>http://whhotw.github.io/blog/2017/11/28/leetcode-number-2-add-two-numbers</id>
    <content type="html"><![CDATA[<p><em>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</em></p>

<p><em>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</em></p>

<p><em>Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8</em></p>

<blockquote><p>相加兩個 linked lists</p></blockquote>

<p>兩個 list 不一定會是等長，因此當沒有下一個節點的時候會新增一個假的節點，在下一回合檢查的時候 <code>if (!l1.next &amp;&amp; !l2.next)</code> 為真即最後回合。</p>

<p>PS. 處理進位問題不是很漂亮應該有更好的寫法！</p>

<pre><code>var addTwoNumbers = function(l1, l2) {
    if (l1 &amp;&amp; l2) { 
        let val = l1.val + l2.val;
        let l = new ListNode(val % 10);

        if (!l1.next &amp;&amp; !l2.next) {
            l.next = (val &gt; 9 ? new ListNode(1) : null);
            return l;
        }

        if (!l1.next) {
            l1.next = new ListNode(0);
        }

        if (!l2.next) {
            l2.next = new ListNode(0);
        }

        if (val &gt; 9) {
            if (l1.next) {
                l1.next.val++;    
            } else {
                l1.next = new ListNode(1);
            }
        }

        l.next = addTwoNumbers(l1.next, l2.next);    
        return l;
    } else {
        return null;
    }
};
</code></pre>
]]></content>
  </entry>
  
</feed>
