<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Leetcode | wlog]]></title>
  <link href="http://whhotw.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://whhotw.github.io/"/>
  <updated>2017-12-14T04:32:08+08:00</updated>
  <id>http://whhotw.github.io/</id>
  <author>
    <name><![CDATA[w]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Leetcode #2. Add Two Numbers]]></title>
    <link href="http://whhotw.github.io/blog/2017/11/28/leetcode-number-2-add-two-numbers/"/>
    <updated>2017-11-28T17:31:11+08:00</updated>
    <id>http://whhotw.github.io/blog/2017/11/28/leetcode-number-2-add-two-numbers</id>
    <content type="html"><![CDATA[<p><em>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</em></p>

<p><em>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</em></p>

<p><em>Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8</em></p>

<blockquote><p>相加兩個 linked lists</p></blockquote>

<p>兩個 list 不一定會是等長，因此當沒有下一個節點的時候會新增一個假的節點，在下一回合檢查的時候 <code>if (!l1.next &amp;&amp; !l2.next)</code> 為真即最後回合。</p>

<p>PS. 處理進位問題不是很漂亮應該有更好的寫法！</p>

<pre><code>var addTwoNumbers = function(l1, l2) {
    if (l1 &amp;&amp; l2) { 
        let val = l1.val + l2.val;
        let l = new ListNode(val % 10);

        if (!l1.next &amp;&amp; !l2.next) {
            l.next = (val &gt; 9 ? new ListNode(1) : null);
            return l;
        }

        if (!l1.next) {
            l1.next = new ListNode(0);
        }

        if (!l2.next) {
            l2.next = new ListNode(0);
        }

        if (val &gt; 9) {
            if (l1.next) {
                l1.next.val++;    
            } else {
                l1.next = new ListNode(1);
            }
        }

        l.next = addTwoNumbers(l1.next, l2.next);    
        return l;
    } else {
        return null;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode #102. Binary Tree Level Order Traversal]]></title>
    <link href="http://whhotw.github.io/blog/2017/11/27/leetcode-number-102-binary-tree-level-order-traversal/"/>
    <updated>2017-11-27T13:30:41+08:00</updated>
    <id>http://whhotw.github.io/blog/2017/11/27/leetcode-number-102-binary-tree-level-order-traversal</id>
    <content type="html"><![CDATA[<p>分層印出二元樹的元素，自己寫了遞迴的方式，紀錄一下</p>

<pre><code>let toArray = (root, arr, level, idx) =&gt; {
    if (!root) {
        return null;
    } else {
        if (!arr[level]) {
            arr[level] = [];
        }

        arr[level].push(root.val);
    }

    toArray(root.left, arr, level + 1, idx * 2);
    toArray(root.right, arr, level + 1, idx * 2 + 1);
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode #357. Count Numbers With Unique Digits]]></title>
    <link href="http://whhotw.github.io/blog/2017/11/16/leetcode-number-357-count-numbers-with-unique-digits/"/>
    <updated>2017-11-16T14:44:14+08:00</updated>
    <id>http://whhotw.github.io/blog/2017/11/16/leetcode-number-357-count-numbers-with-unique-digits</id>
    <content type="html"><![CDATA[<p><em>Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x &lt; 10n.
Example:
Given n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x &lt; 100, excluding [11,22,33,44,55,66,77,88,99])</em></p>

<p>起初用暴力解但效率只能到達 n=6, 以上就會 time limit exceeded</p>

<p><strong>我自己想的解法</strong></p>

<pre><code>var countNumbersWithUniqueDigits = function(n) {
    console.log(Math.pow(10, n));
    let maxNum = Math.pow(10, n);
    let count = 0;
    for (let i = 10; i &lt; maxNum; i++) {
        let arr = i.toString().split('');
        let set = new Set(arr);
        if (arr.length !== set.size) {
            count++;
        }
    }

    return maxNum - count;
};
</code></pre>

<p><strong>參考解答後優化的解法</strong></p>

<pre><code>var countNumbersWithUniqueDigits = function(n) {
    if (n === 0) {
        return 1;
    } else {
        let v = 9;
        for (let i = 1; i &lt; n; i++) {
            v *= (11 - i - 1);
        }

        return countNumbersWithUniqueDigits(n - 1) + v;
    }
};
</code></pre>

<p>主要是運用動態規劃的方式</p>

<pre><code>f(1)=f(0)+9
f(2)=f(1)+9*9
f(3)=f(2)+9*9*8
...
f(9)=f(8)+9*8*7*6*5*4*3*2
f(10)=f(9)+9*8*7*6*5*4*3*2*1
</code></pre>
]]></content>
  </entry>
  
</feed>
