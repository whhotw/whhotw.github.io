<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | wlog]]></title>
  <link href="http://whhotw.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://whhotw.github.io/"/>
  <updated>2018-04-03T14:26:46+08:00</updated>
  <id>http://whhotw.github.io/</id>
  <author>
    <name><![CDATA[w]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fetch API Content-Type]]></title>
    <link href="http://whhotw.github.io/blog/2018/03/20/fetch-api-content-type/"/>
    <updated>2018-03-20T09:38:46+08:00</updated>
    <id>http://whhotw.github.io/blog/2018/03/20/fetch-api-content-type</id>
    <content type="html"><![CDATA[<p>最近用到 js 中的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">fetch</a> 發現 <code>Content-Type</code> 會因為參數而改變</p>

<p>例如</p>

<pre><code>const options = {
  method,
  headers: {
    Accept: 'application/json',
    'Content-Type': 'application/json', // 指定
  },
  body: params, // 第二張圖
  // body: JSON.stringify(params), // 第一張圖
};

return fetch(url, options)
  .then((res) =&gt; {
    if (!res.ok) {
      throw new Error('請檢查網路連線');
    }

    return res.json();
  });
</code></pre>

<p>假如 <code>params</code> 沒有用 <code>JSON.stringify</code> 的話，實際傳出去的 <code>Content-Type</code> 不一定是 <code>application/json</code></p>

<p>我用 wireshark 做的實驗</p>

<p><img src="/assets/Screen%20Shot%202018-03-20%20at%2009.44.19.png" width="1080" height="1920"></p>

<p><img src="/assets/Screen%20Shot%202018-03-20%20at%2009.44.05.png" width="1080" height="1920"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 20 Kinds of Methods]]></title>
    <link href="http://whhotw.github.io/blog/2018/01/15/javascript-20-kinds-of-methods/"/>
    <updated>2018-01-15T11:20:21+08:00</updated>
    <id>http://whhotw.github.io/blog/2018/01/15/javascript-20-kinds-of-methods</id>
    <content type="html"><![CDATA[<p>js 中 20 種必須知道的陣列方法</p>

<p><img src="https://raw.githubusercontent.com/tooto1985/js-array-operations/master/main.jpg" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[淺拷貝 vs. 深拷貝]]></title>
    <link href="http://whhotw.github.io/blog/2018/01/11/"/>
    <updated>2018-01-11T22:21:31+08:00</updated>
    <id>http://whhotw.github.io/blog/2018/01/</id>
    <content type="html"><![CDATA[<h3>複製物件你可能會這麼寫</h3>

<pre><code>let a = {a: '1', b: '2', c: '3'};
let x = a;
x.a = 10
console.log(a); // {a: '10', b: '2', c: '3'}
console.log(x === a); // true
</code></pre>

<p>為什麼新的變數內容改變，舊的變數內容也會變呢？因為以上的寫法為<code>淺拷貝</code>但是很多時候我們並不想這樣，這時候就需要改成<code>深拷貝</code>的寫法</p>

<h3>淺拷貝 => 分身術</h3>

<p>外表（值）長得一樣，靈魂（記憶體位置）<strong>相同</strong></p>

<h3>深拷貝 => 雙胞胎</h3>

<p>外表（值）長得一樣，靈魂（記憶體位置）<strong>不同</strong></p>

<h3>比較圖</h3>

<p><img src="http://i.stack.imgur.com/hOPkR.png" alt="image" /></p>

<h3>Object.assign</h3>

<p>ES6 上可以用的函式但只能處理深度只有一層的物件</p>

<pre><code>let a = {a: '1', b: '2', c: '3'};
let x = Object.assign({}, a);
x.a = 10
console.log(a); // {a: '1', b: '2', c: '3'}
console.log(x === a); // false
</code></pre>

<h3>lodash</h3>

<p>網路上熱門的<a href="https://lodash.com/">函式庫</a></p>

<pre><code>let _ = require('lodash');
let a = {a: '1', b: '2', c: '3'};
let x = _.cloneDeep(a);
x.a = 10
console.log(a); // {a: '1', b: '2', c: '3'}
console.log(x === a); // false
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 中 This 的種種]]></title>
    <link href="http://whhotw.github.io/blog/2018/01/09/javascript-zhong-de-this/"/>
    <updated>2018-01-09T09:56:40+08:00</updated>
    <id>http://whhotw.github.io/blog/2018/01/09/javascript-zhong-de-this</id>
    <content type="html"><![CDATA[<p>JavaScript 中的 this 是一個很容易搞混的東東。</p>

<p>具名函數搭配 bind 的寫法</p>

<pre><code>function wth() {
    console.log(this);
}

let o = {
    name: 1
};

wth(); // window

let wthBind = wth.bind(o);

wthBind(); // object o
</code></pre>

<p>使用箭頭函數</p>

<pre><code>let wth = () =&gt; {
    console.log(this);
};

let o = {
    name: 1
};

wth(); // window

let wthBind = wth.bind(o);

wthBind(); // window
</code></pre>

<p>為什麼執行結果不同呢？是因為透過箭頭函數 this 對象會在宣告時就綁定，因此就算之後用 bind 也不會有變化</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 動態載入模組]]></title>
    <link href="http://whhotw.github.io/blog/2017/11/20/mo-zu/"/>
    <updated>2017-11-20T15:53:41+08:00</updated>
    <id>http://whhotw.github.io/blog/2017/11/20/mo-zu</id>
    <content type="html"><![CDATA[<p>兩個關鍵字 <code>import</code> <code>export</code>，用於載入與輸出模組。但實際上不一定會使用到模組的程式碼，這時候就需要動態載入，在確定需要使用的時候載入</p>

<pre><code>export let go = () =&gt; {
    return 'AAA';
};

async () =&gt; {
    let Module = await import('./Module.js');
    console.log(Module.go());
}
</code></pre>

<p>輸出</p>

<pre><code>AAA
</code></pre>
]]></content>
  </entry>
  
</feed>
